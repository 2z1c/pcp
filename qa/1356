#!/bin/sh
# PCP QA Test No. 1356
# Check selinux attributes, types and classes
#
# Copyright (c) 2021 Ken McDonell.  All Rights Reserved.
#

if [ $# -eq 0 ]
then
    seq=`basename $0`
    echo "QA output created by $seq"
else
    # use $seq from caller, unless not set
    [ -n "$seq" ] || seq=`basename $0`
    echo "QA output created by `basename $0` $*"
fi

# get standard environment, filters and checks
. ./common.product
. ./common.filter
. ./common.check

eval `sed -n -e '/^PCP_SELINUX_DIR *=/s/  *//gp'  /usr/include/pcp/builddefs`
[ -z "$PCP_SELINUX_DIR" ] && _notrun "PCP_SELINIX_DIR not defined in /usr/include/pcp/builddefs"
[ ! -d "$PCP_SELINUX_DIR" ] && _notrun "$PCP_SELINUX_DIR: dir not found"

_cleanup()
{
    cd $here
    $sudo rm -rf $tmp $tmp.*
}

status=0	# success is the default!
$sudo rm -rf $tmp $tmp.* $seq.full
trap "_cleanup; exit \$status" 0 1 2 3 15

_filter()
{
    sed \
	-e 's/<something>/<else>/' \
    # end
}

# attributes
#
seinfo -a >$tmp.attr

# types
#
seinfo -t >$tmp.type

# classes
#
seinfo -c >$tmp.class

# real QA test starts here

for rule in $PCP_SELINUX_DIR/pcpupstream.te \
    $PCP_SELINUX_DIR/pcpupstream-container.te pcpqa.te
do
    echo
    echo "$rule:" | sed -e "s@$PCP_SELINUX_DIR@PCP_SELINUX_DIR@"
    if [ ! -f $rule ]
    then
	echo "Warning: $rule: not found"
	continue
    fi
    $PCP_AWK_PROG <$rule >$tmp.tmp '
$1 == "require"		{ req = 1; next }
req == 1 && $1 == "}"	{ exit }
req == 1		{ print }'

    rm -f $tmp.err
    sed -n <$tmp.tmp -e '/^[ 	]*attribute */{
s///
s/[ 	]*#.*//
s/;//
p
}' \
    | while read attr
    do
	if grep "^[ 	]*$attr\$" $tmp.attr >/dev/null
	then
	    :
	else
	    echo "Error: Attribute \"$attr\" in $rule but not in seinfo -a output"
	    touch $tmp.err
	fi
    done
    [ -f $tmp.err ] || echo "Attributes OK"

    rm -f $tmp.err
    sed -n <$tmp.tmp -e '/^[ 	]*type */{
s///
s/[ 	]*#.*//
s/;//
p
}' \
    | while read type
    do
	if grep "^[ 	]*$type\$" $tmp.type >/dev/null
	then
	    :
	else
	    echo "Error: Type \"$type\" in $rule but not in seinfo -t output"
	    touch $tmp.err
	fi
    done
    [ -f $tmp.err ] || echo "Types OK"

    rm -f $tmp.err
    sed -n <$tmp.tmp -e '/^[ 	]*class */{
s///
s/[ 	]*#.*//
s/{//
s/}//
s/;//
p
}' \
    | while read class perms
    do
	if grep "^[ 	]*$class\$" $tmp.class >/dev/null
	then
	    seinfo -x --common --class=$class >$tmp.perm
	    for perm in $perms
	    do
		if grep "^[ 	]*$perm\$" $tmp.perm >/dev/null
		then
		    :
		else
		    echo "Error: Permission \"$perm\" for Class \"$class\" in $rule but not in seinfo -x --class=$class output"
		    touch $tmp.err
		fi
	    done
	else
	    echo "Error: Class \"$class\" in $rule but not in seinfo -c output"
	    touch $tmp.err
	fi
    done
    [ -f $tmp.err ] || echo "Classes and Permissions OK"

done

# success, all done
exit
